from fastapi import FastAPI
import subprocess
import csv
import statistics
import json
import os
import time

# Initialize FastAPI application
app = FastAPI()

# PATH CONFIGURATION
# Path to the CSV file generated by the competitor price script
CSV_PATH = "/data/eu_products_prices.csv"

# Path to the JSON file used by the Flask web example
PRODUCT_JSON = "/data/Web_Example/product_data.json"


# HELPER FUNCTIONS
def load_product():
    """
    Load product data from JSON file.
    This file represents the product displayed on the Flask example page.
    """
    with open(PRODUCT_JSON, "r", encoding="utf-8") as f:
        return json.load(f)


def save_product(product):
    """
    Save updated product data back to the JSON file.
    This allows the Flask page to reflect price changes immediately.
    """
    with open(PRODUCT_JSON, "w", encoding="utf-8") as f:
        json.dump(product, f, indent=4)


# ROUTE 1: CHECK PRICE
@app.get("/check_price")
def check_price():
    """
    Executes the competitor price collection script,
    reads generated prices from CSV, calculates the median price,
    and returns product metadata along with price comparison data.
    """
    try:
        # Run the external Python script that collects competitor prices
        subprocess.run(
            ["python3", "/data/check_competiton.py"],
            capture_output=True,
            text=True,
            check=True  # Raises an exception if the script fails
        )

        # Wait for the CSV file to be created (max 5 seconds)
        timeout = 5
        start = time.time()
        while not os.path.exists(CSV_PATH) and time.time() - start < timeout:
            time.sleep(0.5)

        # Read prices from the generated CSV file
        prices = []
        if os.path.exists(CSV_PATH):
            with open(CSV_PATH, newline="", encoding="utf-8") as f:
                reader = csv.DictReader(f)
                for row in reader:
                    try:
                        prices.append(float(row["price_usd"]))
                    except ValueError:
                        # Skip invalid or missing price values
                        continue

        # Calculate the median competitor price
        median_price = statistics.median(prices) if prices else None

        # Load current product data
        product = load_product()
        old_price = product.get("price")
        product_title = product.get("title")
        product_sku = product.get("sku")

        return {
            "success": True,
            "old_price": old_price,
            "median_price": median_price,
            "product_title": product_title,
            "product_sku": product_sku,
            "total_items": len(prices)
        }

    except Exception as e:
        # Return error details if any step fails
        return {
            "success": False,
            "error": str(e)
        }


# ROUTE 2: UPDATE PRICE
@app.post("/update_price/{new_price}")
def update_price(new_price: float):
    """
    Updates the product price in the JSON file.
    This endpoint is typically triggered by n8n after
    price difference validation logic.
    """
    try:
        product = load_product()
        old_price = product.get("price")

        # Update product price
        product["price"] = new_price
        save_product(product)

        return {
            "success": True,
            "old_price": old_price,
            "new_price": new_price
        }

    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

